Expressions:
- compute a value but nothing happens (no program state alteration on their own)
- ex. let x = 1, y = 2;


Statements:
- no inherent value but they can alter program state
- ex. x <= y


Control Structures:
- conditional statements and loops
- ex. while (x <= y) { x++ }


Arrow Functions:
- allows one to pass an unnamed function as an argument to another function
- ex. const plusOne = x => x + 1; // the input 'x' maps to the output 'x + 1'


Primitive Value Types:
- number, string, boolean, null, undefined, symbol
- null and undefined are the only primitives that methods cannot be invoked on
	-- null = program-level, normal, expected absense of value
	-- undefined = system-level, unexpected, potentially error-like absense of value


Objects:
- functions used with/on objects are 'methods'
	-- all JavaScript objects have inherent/built-in methods
- 'this' keyword refers to the object on which the method is defined
- object value types = anything that is not a primitive value (see above)
- collection of properties that have key/value pairs, where the value can be a primitive or another object (i.e. nested object)
- ordinary objects = unordered named values
	-- arrays (objects) = ordered numbered values (i.e. indexed values)
- functions and classes are specialized objects
- global object:
	-- properties of this object are the globally-defined identifiers available to the JavaScript program being run
		--- properties defined:
			---- global constants (e.g. undefined, Infinity, NaN)
			---- global functions (e.g. isNaN(), parseInt(), eval())
			---- constructor functions (e.g. Date(), RegExp(), String(), Object(), Array())
	-- gets created whenever the JavaScript interpreter starts running and whenever a web browser loads a web page
	-- ES6 2020 introduced "globalThis" as the new standard to refer to the global object in any context


Pillars of Object-Oriented Programming:
- procedural programming:
	-- "decoupled," older style of of programming that came before OoP, can easily lead to spaghetti code
	-- while it's simple and straightforward, there's a significant amount of interdependencies among functions and variables with numerous function parameters
	-- ex.
		--- let varOne = value x;
			let varTwo = value y;
			let varThree = value z;
			function func(param 1, param 2, param 3) {
				return param 1 + (param 2 * param 3);
			}
- object-oriented programming:
	-- provides "encapsulation," which reduces complexity
		--- variables and the associated functions are closely related so they are grouped together as part of a single unit
		--- allows for fewer function parameters, which reduces chances of spaghetti code
		--- ex.
			---- let newObject = {
				varOne: value x,
				varTwo: value y,
				varThree: value z,
				function: func() {
					return this.varOne + (this.varTwo * this.varThree);
				}
				};
				newObject.function();
		--- "The best functions are those with no parameters." meaning fewer parameters in functions is better for usability/maintainability
	-- provides "abstraction," which reduces unnecessary access to objects/properties
		--- simplifies object interfaces through fewer properties and methods, which improves the programmers' understandability and usability of the object/code
		--- reduces impact of changes to objects
		--- hides details and complexity, showing only essential code
	-- provides "inheritance," which reduces redundant code
		--- apply common properties and methods to any number of like-objects, removing the need to re-set each property and variable among the newly created objects
		--- enables 'polymorphism,' which removes the need for long if...else statements and switch...case statements
- working with objects:
	-- 