Expressions:
- compute a value but nothing happens (no program state alteration on their own)
- ex. let x = 1, y = 2;


Statements:
- no inherent value but they can alter program state
- ex. x <= y


Control Structures:
- conditional statements and loops
- ex. while (x <= y) { x++ }


Arrow Functions:
- allows one to pass an unnamed function as an argument to another function
- ex. const plusOne = x => x + 1; // the input 'x' maps to the output 'x + 1'


Primitive Value Types:
- number, string, boolean, null, undefined, symbol
- null and undefined are the only primitives that methods cannot be invoked on
	-- null = program-level, normal, expected absense of value
	-- undefined = system-level, unexpected, potentially error-like absense of value


Objects:
- functions used with/on objects are 'methods'
	-- all JavaScript objects have inherent/built-in methods
- 'this' keyword refers to the object on which the method is defined
- object value types = anything that is not a primitive value (see above)
- collection of properties that have key/value pairs, where the value can be a primitive or another object (i.e. nested object)
- ordinary objects = unordered named values
	-- arrays (objects) = ordered numbered values (i.e. indexed values)
- functions and classes are specialized objects
- global object:
	-- properties of this object are the globally-defined identifiers available to the JavaScript program being run
		--- properties defined:
			---- global constants (e.g. undefined, Infinity, NaN)
			---- global functions (e.g. isNaN(), parseInt(), eval())
			---- constructor functions (e.g. Date(), RegExp(), String(), Object(), Array())
	-- gets created whenever the JavaScript interpreter starts running and whenever a web browser loads a web page
	-- ES6 2020 introduced "globalThis" as the new standard to refer to the global object in any context


Pillars of Object-Oriented Programming:
- procedural programming:
	-- "decoupled," older style of of programming that came before OoP, can easily lead to spaghetti code
	-- while it's simple and straightforward, there's a significant amount of interdependencies among functions and variables with numerous function parameters
	-- ex.
		--- let varOne = value x;
			let varTwo = value y;
			let varThree = value z;
			function func(param 1, param 2, param 3) {
				return param 1 + (param 2 * param 3);
			}
- object-oriented programming:
	-- provides "encapsulation," which reduces complexity
		--- variables and the associated functions are closely related so they are grouped together as part of a single unit
		--- allows for fewer function parameters, which reduces chances of spaghetti code
		--- ex.
			---- let newObject = {
				varOne: value x,
				varTwo: value y,
				varThree: value z,
				function: func() {
					return this.varOne + (this.varTwo * this.varThree);
				}
				};
				newObject.function();
		--- "The best functions are those with no parameters." meaning fewer parameters in functions is better for usability/maintainability
	-- provides "abstraction," which reduces unnecessary access to objects/properties
		--- simplifies object interfaces through fewer properties and methods, which improves the programmers' understandability and usability of the object/code
		--- reduces impact of changes to objects
		--- hides details and complexity, showing only essential code
	-- provides "inheritance," which reduces redundant code
		--- apply common properties and methods to any number of like-objects, removing the need to re-set each property and variable among the newly created objects
		--- enables 'polymorphism,' which removes the need for long if...else statements and switch...case statements
- working with objects:
	-- object-literal syntax ({}) not the best for creating and duplicating objects with one or more methods (i.e. behaviors)
	-- 'Factory' function:
		--- function createCircle(radius) {
				return {
					radius, // same as saying 'radius: radius'
					draw: function() {
						console.log('Drawing now...');
					}
				}
			}
			const circle = createCircle(2); 
			circle.radius // expected output: 2
			circle.draw(); // expected output: "Drawing now..."
	-- 'Constructor' function (similar to 'class' in other langs):
		--- function Circle(radius) {
				this.radius = radius,
				this.draw = function() {
					console.log('Drawing now...');
				}
			}
			const newCircle = new Circle(2);
			---- "new" operator creates an empty object, points 'this' scope to that new empty object, then returns the object defined in the function
	-- while both Factory and Constructor functions create new objects, Factory functions simply create an object and return it while Constructor functions are classes (templates, blueprints, etc.) of objects which can get created with the 'new' keyword